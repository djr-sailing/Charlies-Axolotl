<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Charlie's Axolotl Pet</title>
<meta property="og:title" content="Charlie's Axolotl Pet" />
<meta name="twitter:title" content="Charlie's Axolotl Pet" />
<style>
  :root{
    --bg:#f7f5ff; --card:#fff; --text:#222; --muted:#6b6b6b; --accent:#7c5cff;
    --good:#4caf50; --warn:#ffb300; --bad:#ff5252;
  }
  html,body{height:100%;margin:0;background:
    radial-gradient(1000px 700px at 20% -10%, #ffe9f2, transparent 60%),
    radial-gradient(800px 500px at 120% 10%, #eaf4ff, transparent 50%),
    var(--bg);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
    color:var(--text);
  }
  .wrap{max-width:520px;margin:0 auto;padding:16px 12px calc(env(safe-area-inset-bottom, 0) + 24px);}
  .card{background:var(--card);border-radius:20px;box-shadow:0 10px 30px rgba(50,34,120,.1);padding:10px 10px 14px;}
  .topbar{display:flex;align-items:center;justify-content:space-between;gap:8px;margin-bottom:8px;}
  .title{font-weight:800;letter-spacing:.3px;font-size:16px;display:flex;align-items:center;gap:8px;}
  .title .dot{width:10px;height:10px;border-radius:50%;background:var(--accent);}
  .controls{display:flex;align-items:center;gap:8px;}
  .controls input[type="text"]{width:160px;border:1px solid #e5e5ee;border-radius:12px;padding:6px 10px;outline:none;background:#fbfbff;}
  .controls input[type="color"]{appearance:none;border:none;width:32px;height:32px;background:none;padding:0;}
  .controls input[type="color"]::-webkit-color-swatch-wrapper{padding:0;}
  .controls input[type="color"]::-webkit-color-swatch{border:2px solid #e5e5ee;border-radius:8px;}
  .canvas-holder{border-radius:16px;overflow:hidden;outline:1px solid rgba(124,92,255,.10);}
  #gameCanvas{display:block;width:100%;background:#0b0b10;}
  .bars{display:grid;grid-template-columns:1fr;gap:8px;margin:12px 4px 6px;}
  .bar{background:#f2f0ff;border-radius:999px;height:12px;position:relative;overflow:hidden;}
  .bar span{position:absolute;left:0;top:0;bottom:0;width:50%;background:linear-gradient(90deg,#9d82ff,#ff7ad9);border-radius:999px;transition:width .25s ease;}
  .barlabel{font-size:12px;color:var(--muted);margin:0 6px 2px;display:flex;justify-content:space-between;}
  .actions{display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-top:10px;}
  .btn{border:none;padding:10px 8px;border-radius:14px;background:#f5f3ff;cursor:pointer;font-weight:700;font-size:12px;
       display:flex;flex-direction:column;align-items:center;gap:6px;box-shadow:inset 0 0 0 1px rgba(124,92,255,.15);}
  .btn:active{transform:translateY(1px) scale(.99);}
  .btn .emoji{font-size:20px;}
  .hint{text-align:center;font-size:12px;color:var(--muted);margin-top:10px;}
  /* Debug overlay */
  #debug{position:fixed;left:8px;bottom:8px;max-width:90vw;background:#2b2b2b;color:#fff;font:12px/1.3 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
         padding:8px 10px;border-radius:8px;box-shadow:0 10px 30px rgba(0,0,0,.25);display:none;white-space:pre-wrap;z-index:9999;}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <div class="topbar">
      <div class="title"><span class="dot"></span> Charlie's Axolotl Pet</div>
      <div class="controls">
        <input id="nameInput" type="text" placeholder="Name meâ€¦" />
        <input id="colorInput" type="color" value="#f6b6d2" title="Axolotl color" />
      </div>
    </div>

    <div class="canvas-holder" id="canvasHolder">
      <canvas id="gameCanvas"></canvas>
    </div>

    <div class="bars">
      <div class="barlabel"><span>Hunger</span><strong id="hungerVal">â€”</strong></div>
      <div class="bar"><span id="hungerBar"></span></div>
      <div class="barlabel"><span>Fun</span><strong id="funVal">â€”</strong></div>
      <div class="bar"><span id="funBar"></span></div>
      <div class="barlabel"><span>Energy</span><strong id="energyVal">â€”</strong></div>
      <div class="bar"><span id="energyBar"></span></div>
      <div class="barlabel"><span>Clean</span><strong id="cleanVal">â€”</strong></div>
      <div class="bar"><span id="cleanBar"></span></div>
    </div>

    <div class="actions">
      <button class="btn" id="feed"><span class="emoji">ðŸ«—</span>Feed</button>
      <button class="btn" id="play"><span class="emoji">ðŸŽ¾</span>Play</button>
      <button class="btn" id="sleep"><span class="emoji">ðŸŒ™</span>Sleep</button>
      <button class="btn" id="clean"><span class="emoji">ðŸ«§</span>Clean</button>
    </div>

    <div class="hint">Tip: tap the tank to drop a single food flake. Everything autosaves.</div>
  </div>
</div>

<div id="debug"></div>

<script>
/* =========================
   Mobile-safe canvas setup
   ========================= */
const holder = document.getElementById('canvasHolder');
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });

function sizeCanvas(){
  const cssW = Math.max(300, holder.clientWidth || 360);
  const cssH = Math.round(cssW * 16/9);
  canvas.style.width = cssW + 'px';
  canvas.style.height = cssH + 'px';
  const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  const w = cssW * dpr, h = cssH * dpr;
  if (canvas.width !== w || canvas.height !== h) { canvas.width = w; canvas.height = h; }
  ctx.setTransform(1,0,0,1,0,0);
  ctx.scale(dpr, dpr);
}
window.addEventListener('resize', sizeCanvas, { passive: true });
window.addEventListener('orientationchange', () => setTimeout(sizeCanvas, 50), { passive: true });

/* =========================
   State, UI & persistence
   ========================= */
const STORAGE_KEY = 'axolotl_tank_play_v1';
const defaultState = () => ({
  name: 'Axie',
  color: '#f6b6d2',
  stats: { hunger: 70, fun: 70, energy: 70, clean: 70 },
  lastTick: Date.now(),
  sleeping: false
});
function loadState(){ try{ const raw = localStorage.getItem(STORAGE_KEY); if(!raw) return defaultState();
  const data = JSON.parse(raw); return {...defaultState(), ...data, stats:{...defaultState().stats, ...(data.stats||{})}};
} catch{ return defaultState(); } }
function saveState(){ try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }catch{} }
function clamp(v){ return Math.max(0, Math.min(100, v)); }
let state = loadState();

const nameInput = document.getElementById('nameInput');
const colorInput = document.getElementById('colorInput');
const hungerBar = document.getElementById('hungerBar');
const funBar    = document.getElementById('funBar');
const energyBar = document.getElementById('energyBar');
const cleanBar  = document.getElementById('cleanBar');
const hungerVal = document.getElementById('hungerVal');
const funVal    = document.getElementById('funVal');
const energyVal = document.getElementById('energyVal');
const cleanVal  = document.getElementById('cleanVal');

nameInput.value = state.name;
colorInput.value = state.color;

nameInput.addEventListener('input', ()=>{ state.name = nameInput.value || 'Axie'; saveState(); });
colorInput.addEventListener('input', ()=>{ state.color = colorInput.value; saveState(); });

function moodScore(){ const s = state.stats;
  return Math.max(0, Math.min(1, (s.hunger + s.fun + s.energy + s.clean)/400)); }
function setBar(el, val, labelEl){
  const pct = clamp(val); el.style.width = pct + '%'; labelEl.textContent = Math.round(pct);
  let bg = 'linear-gradient(90deg, #9d82ff, #ff7ad9)';
  if(pct < 30) bg = 'linear-gradient(90deg, var(--bad), #ff9aa6)';
  else if(pct < 60) bg = 'linear-gradient(90deg, var(--warn), #ffd16b)'; else bg = 'linear-gradient(90deg, var(--good), #7dffa6)';
  el.style.background = bg;
}
function refreshBars(){ const s = state.stats;
  setBar(hungerBar, s.hunger, hungerVal); setBar(funBar, s.fun, funVal);
  setBar(energyBar, s.energy, energyVal); setBar(cleanBar, s.clean, cleanVal); }

/* =========================
   Environment & visuals
   ========================= */
const bg = document.createElement('canvas');
const bgCtx = bg.getContext('2d');

function drawTankBackground(w, h){
  bg.width = w; bg.height = h;
  const g = bgCtx;
  g.setTransform(1,0,0,1,0,0);
  const grad = g.createLinearGradient(0,0,0,h);
  grad.addColorStop(0, '#cfefff'); grad.addColorStop(0.5, '#d9f4ff'); grad.addColorStop(1, '#eafaff');
  g.fillStyle = grad; g.fillRect(0,0,w,h);
  const rad = g.createRadialGradient(w*0.5, h*0.2, w*0.1, w*0.5, h*0.2, w*0.8);
  rad.addColorStop(0,'rgba(255,255,255,0)'); rad.addColorStop(1,'rgba(0,30,60,0.12)');
  g.fillStyle = rad; g.fillRect(0,0,w,h);
  // substrate
  const bedH = h*0.18, bedY = h - bedH;
  g.fillStyle = '#d7c7a2'; roundRect(g, 0, bedY, w, bedH, 18, true);
  for(let i=0;i<160;i++){
    const px = Math.random()*w, py = bedY + Math.random()*bedH*0.9, r = 1.5 + Math.random()*3.5;
    g.fillStyle = pebbleColor();
    g.beginPath(); g.ellipse(px, py, r*1.2, r, Math.random()*Math.PI, 0, Math.PI*2); g.fill();
  }
  drawRock(g, w*0.18, bedY-6, 48, 28); drawRock(g, w*0.30, bedY-2, 32, 18);
  drawCave(g, w*0.72, bedY-4, 110, 60);
  drawPlantCluster(g, w*0.1,  bedY, 6,  bedH*0.9);
  drawPlantCluster(g, w*0.42, bedY, 7,  bedH*1.0);
  drawPlantCluster(g, w*0.86, bedY, 5,  bedH*0.85);
}
function pebbleColor(){ const p=['#cdbb96','#b8a57e','#e3d5b0','#a18f72','#d1c09d','#b59f7a']; return p[(Math.random()*p.length)|0]; }
function drawRock(g, x, y, w, h){ g.save(); g.translate(x,y);
  const grd = g.createLinearGradient(0,-h,0,h); grd.addColorStop(0,'#8f978f'); grd.addColorStop(1,'#6c746c');
  g.fillStyle = grd; g.beginPath(); g.moveTo(-w*0.5,0); g.quadraticCurveTo(0,-h, w*0.5,0); g.closePath(); g.fill(); g.restore(); }
function drawCave(g, x, y, w, h){
  g.save(); g.translate(x,y); g.fillStyle = '#6b6e6f';
  g.beginPath(); g.moveTo(-w/2,0); g.quadraticCurveTo(0,-h, w/2,0); g.quadraticCurveTo(0,-h*0.6, -w/2,0); g.fill();
  g.fillStyle = '#1c2426'; g.beginPath(); g.ellipse(0, h*0.12, w*0.36, h*0.25, 0, 0, Math.PI*2); g.fill(); g.restore();
}
function drawPlantCluster(g, baseX, baseY, stems, height){ for(let i=0;i<stems;i++){ const sway=(Math.random()*0.6+0.6);
  drawPlant(g, baseX + (i - stems/2)*8, baseY, height*(0.7+Math.random()*0.5), sway); } }
function drawPlant(g, x, baseY, h, k){
  g.save(); g.strokeStyle='#2f8f6e'; g.lineWidth=3; g.beginPath(); g.moveTo(x, baseY);
  for(let t=0;t<=1;t+=0.1){ const y = baseY - h*t; const curv = Math.sin(t*Math.PI)*k*20; const cx = x + curv; if(t===0) g.lineTo(x,y); else g.lineTo(cx,y); }
  g.stroke();
  for(let i=0;i<5;i++){ const sy=baseY - h*(i/6 + 0.1); g.fillStyle='#39a57f';
    g.beginPath(); g.ellipse(x + (i%2? 10:-10), sy, 10, 4, (i%2?0.6:-0.6), 0, Math.PI*2); g.fill(); }
  g.restore();
}
function roundRect(g, x, y, w, h, r, fill){ const rr=Math.min(r,w/2,h/2);
  g.beginPath(); g.moveTo(x+rr,y); g.arcTo(x+w,y,x+w,y+h,rr); g.arcTo(x+w,y+h,x,y+h,rr); g.arcTo(x,y+h,x,y,rr); g.arcTo(x,y,x+w,y,rr); g.closePath(); if(fill) g.fill(); else g.stroke(); }
let causticT = 0;
function drawCaustics(w,h,dt){
  causticT += dt; ctx.globalAlpha=0.06;
  for(let i=0;i<3;i++){ const t=causticT*0.6 + i*0.8;
    ctx.beginPath();
    for(let x=0; x<=w; x+=6){ const y=Math.sin((x*0.015)+t)*6 + Math.cos((x*0.027)-t*1.3)*4 + h*0.35 + i*18;
      if(x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }
    ctx.strokeStyle='#ffffff'; ctx.lineWidth=2; ctx.stroke();
  } ctx.globalAlpha=1;
}

/* =========================
   Axolotl (small, swimming)
   ========================= */
const axolotl = { x:120, y:260, vx:15, vy:0, dir:1, target:null, blinkT:0, eyeOpen:true, nibbleT:0 };
function setRandomTarget(){ const margin=60;
  axolotl.target = { x: margin + Math.random()*(canvas.clientWidth - margin*2),
                     y: canvas.clientHeight*0.35 + Math.random()*canvas.clientHeight*0.35 }; }
function updateAxolotl(dt){
  // choose target: ball during play; else nearest food; else wander
  let target = null; let minD = 1e9;
  if(play.active && play.ball){ target = {x:play.ball.x, y:play.ball.y}; }
  if(!target){
    for(const f of food){ if(!f.eaten){
      const d = Math.hypot(f.x-axolotl.x, f.y-axolotl.y); if(d<minD){minD=d; target=f;}
    }}
  }
  if(target){ axolotl.target = {x:target.x, y:target.y}; }
  else if(!axolotl.target || Math.random()<0.006){ setRandomTarget(); }

  if(axolotl.target){
    const dx=axolotl.target.x - axolotl.x, dy=axolotl.target.y - axolotl.y, d=Math.hypot(dx,dy)||1;
    const maxSpeed = play.active ? 75 : 55;
    const steer = 100;
    const desiredVx = (dx/d)*maxSpeed, desiredVy = (dy/d)*maxSpeed;
    axolotl.vx += (desiredVx - axolotl.vx)*Math.min(1, steer*dt/60);
    axolotl.vy += (desiredVy - axolotl.vy)*Math.min(1, steer*dt/60);
  }
  axolotl.vx *= (1 - 0.05*dt); axolotl.vy *= (1 - 0.05*dt);
  axolotl.x += axolotl.vx * dt; axolotl.y += axolotl.vy * dt;

  const m=24; axolotl.x = Math.max(m, Math.min(canvas.clientWidth-m, axolotl.x));
  axolotl.y = Math.max(canvas.clientHeight*0.28, Math.min(canvas.clientHeight*0.82, axolotl.y));
  if(Math.abs(axolotl.vx)>1) axolotl.dir = axolotl.vx>0 ? 1 : -1;

  axolotl.blinkT += dt;
  if(axolotl.eyeOpen && axolotl.blinkT > 2.6 + Math.random()*0.6){ axolotl.eyeOpen=false; axolotl.blinkT=0; }
  else if(!axolotl.eyeOpen && axolotl.blinkT > 0.14){ axolotl.eyeOpen=true; axolotl.blinkT=0; }

  // Eat nearby food
  for(const f of food){ if(!f.eaten){
    const d = Math.hypot(f.x-axolotl.x, f.y-axolotl.y);
    if(d < 18){ f.eaten=true; axolotl.nibbleT=0.35; state.stats.hunger = clamp(state.stats.hunger + 8); state.stats.fun = clamp(state.stats.fun + 3); refreshBars(); }
  }}

  // Bop the ball
  if(play.active && play.ball){
    const b = play.ball; const dx=b.x-axolotl.x, dy=b.y-axolotl.y, d=Math.hypot(dx,dy);
    if(d < b.r + 16){ // head overlap
      const nx = (dx/d)||1, ny = (dy/d)||0;
      const impulse = 140; // kick strength
      b.vx += nx * impulse; b.vy += ny * impulse;
      axolotl.nibbleT = 0.2;
      state.stats.fun = clamp(state.stats.fun + 0.8);
    }
  }
}
function drawAxolotlSmall(){
  const x=axolotl.x, y=axolotl.y, dir=axolotl.dir;
  const bodyColor = hexToRgb(state.color) || {r:246,g:182,b:210};
  ctx.save(); ctx.translate(x,y); ctx.scale(dir,1);
  const t = performance.now()/1000; const wag = Math.sin(t*8 + x*0.02)*6;

  ctx.fillStyle = `rgba(${bodyColor.r},${bodyColor.g},${bodyColor.b},0.9)`;
  ctx.beginPath(); ctx.ellipse(32, 8, 34, 12, 0.3, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(0, 0, 32, 18, 0, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(-24, -6, 22, 18, 0, 0, Math.PI*2); ctx.fill();

  ctx.fillStyle = 'rgba(255,135,197,0.9)';
  for(let i=0;i<3;i++){ ctx.beginPath(); ctx.ellipse(-36, -12+i*8, 10+i*2, 4, -0.2, 0, Math.PI*2); ctx.fill();
                        ctx.beginPath(); ctx.ellipse(-10, -10+i*8, 10+i*2, 4, 0.2, 0, Math.PI*2); ctx.fill(); }

  ctx.fillStyle = `rgba(${bodyColor.r},${bodyColor.g},${bodyColor.b},0.35)`;
  ctx.beginPath(); ctx.moveTo(-6, -18);
  ctx.quadraticCurveTo(10, -18 - wag*0.08, 26, -10 - wag*0.12);
  ctx.quadraticCurveTo(10, -12, -6, -18); ctx.fill();

  ctx.fillStyle = '#1d1f22';
  if(axolotl.eyeOpen){ ctx.beginPath(); ctx.ellipse(-32, -10, 2.6, 3.4, 0, 0, Math.PI*2); ctx.fill();
                        ctx.beginPath(); ctx.ellipse(-16, -10, 2.6, 3.4, 0, 0, Math.PI*2); ctx.fill();
  } else { ctx.fillRect(-35, -10, 6, 2); ctx.fillRect(-19, -10, 6, 2); }

  ctx.strokeStyle = '#1d1f22'; ctx.lineWidth = 2; ctx.beginPath();
  const smile = axolotl.nibbleT>0 ? 0.0 : 0.6; ctx.moveTo(-30, -2);
  ctx.quadraticCurveTo(-24, -2 + 6*smile, -18, -2); ctx.stroke();
  ctx.restore();
}

/* =========================
   Food flakes & bubbles
   ========================= */
const food = []; // {x,y,vx,vy,rot,spin,size,eaten:false}
function spawnFood(cx, cy, count=10){
  for(let i=0;i<count;i++){
    food.push({ x: cx+(Math.random()*40-20), y: cy+(Math.random()*10-5), vx:(Math.random()*20-10)/60,
      vy:(5+Math.random()*15)/60, rot:Math.random()*Math.PI*2, spin:(Math.random()<0.5?-1:1)*(0.5+Math.random())*0.8,
      size: 4+Math.random()*5, eaten:false });
  }
}
const filterBubbles = [];
function spawnFilterBubble(){ const x=24+Math.random()*10, y=canvas.clientHeight*0.25+Math.random()*30;
  filterBubbles.push({x,y,r:2+Math.random()*2,a:0.8}); }

/* =========================
   PLAY MODE: ball chase
   ========================= */
const play = {
  active: false,
  timer: 0,
  ball: null,      // {x,y,vx,vy,r}
  bubble: { text: "", t: 0 } // speech bubble timer
};
function startPlay(){
  play.active = true;
  play.timer = 20; // seconds
  // spawn ball near top-middle
  play.ball = {
    x: canvas.clientWidth*0.55,
    y: canvas.clientHeight*0.35,
    vx: (Math.random()*120-60),
    vy: (Math.random()*60),
    r: 10
  };
}
function endPlay(){
  play.active = false;
  play.ball = null;
  play.bubble.text = "Thank you for playing with me, Charlie";
  play.bubble.t = 3.5; // show for 3.5s
}
function updateBall(dt){
  if(!play.ball) return;
  const b = play.ball;
  // integrate
  b.vx *= 0.995; b.vy *= 0.995; // mild drag
  b.y += b.vy * dt; b.x += b.vx * dt;
  // bounds (tank water area)
  const left=10, right=canvas.clientWidth-10, top=canvas.clientHeight*0.22, bottom=canvas.clientHeight*0.82;
  if(b.x-b.r < left){ b.x = left + b.r; b.vx = Math.abs(b.vx); }
  if(b.x+b.r > right){ b.x = right - b.r; b.vx = -Math.abs(b.vx); }
  if(b.y-b.r < top){ b.y = top + b.r; b.vy = Math.abs(b.vy); }
  if(b.y+b.r > bottom){ b.y = bottom - b.r; b.vy = -Math.abs(b.vy); }
}
function drawBall(){
  if(!play.ball) return;
  const b = play.ball;
  // soft colored ball with highlight
  const grad = ctx.createRadialGradient(b.x-3, b.y-3, 2, b.x, b.y, b.r);
  grad.addColorStop(0, '#ffe9a9'); grad.addColorStop(1, '#ffb36f');
  ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fill();
  ctx.strokeStyle = 'rgba(0,0,0,0.15)'; ctx.lineWidth = 1; ctx.stroke();
  ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.beginPath(); ctx.arc(b.x-4, b.y-5, 2.5, 0, Math.PI*2); ctx.fill();
}

/* =========================
   Simple interactions
   ========================= */
document.getElementById('feed').onclick = ()=>{
  spawnFood(canvas.clientWidth*0.5, canvas.clientHeight*0.18, 18);
  state.stats.hunger = clamp(state.stats.hunger + 10);
  refreshBars(); saveState();
};
document.getElementById('play').onclick = ()=>{
  // (re)start 20s play session
  startPlay();
  state.stats.fun = clamp(state.stats.fun + 5);
  refreshBars(); saveState();
};
document.getElementById('sleep').onclick = ()=>{
  state.sleeping = !state.sleeping;
  if(state.sleeping) state.stats.energy = clamp(state.stats.energy + 8);
  refreshBars(); saveState();
};
document.getElementById('clean').onclick = ()=>{
  state.stats.clean = clamp(state.stats.clean + 16);
  for(let i=0;i<14;i++){
    filterBubbles.push({ x: canvas.clientWidth*0.5 + (Math.random()*80-40),
      y: canvas.clientHeight*0.78 + Math.random()*6, r: 2+Math.random()*3, a: 0.9 });
  }
  refreshBars(); saveState();
};
// Tap tank = drop flakes at tap
canvas.addEventListener('pointerdown', (e)=>{
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left); const y = (e.clientY - rect.top);
  spawnFood(x, Math.max(20,y), 8);
});

/* =========================
   Game loop & physics
   ========================= */
function tickOneSecond(){
  const s = state.stats;
  const baseDecay = state.sleeping ? 0.6 : 1.0;
  s.hunger = clamp(s.hunger - baseDecay);
  s.fun    = clamp(s.fun - (state.sleeping ? 0.35 : 0.7));
  s.clean  = clamp(s.clean - (state.sleeping ? 0.25 : 0.5));
  s.energy = clamp(s.energy + (state.sleeping ? +2.2 : -0.6));
  if(play.active){ s.fun = clamp(s.fun + 1.0); } // boost fun while playing
  refreshBars();
  state.lastTick = Date.now();
}
function offlineProgress(){
  const now = Date.now(); const dt = Math.max(0, now - (state.lastTick || now));
  const seconds = Math.min(8*3600, Math.floor(dt/1000));
  for(let i=0;i<seconds;i++){ const s=state.stats; const bd = state.sleeping ? 0.5 : 1.0;
    s.hunger = clamp(s.hunger - bd/2);
    s.fun    = clamp(s.fun - (state.sleeping ? 0.15 : 0.35));
    s.clean  = clamp(s.clean - (state.sleeping ? 0.1 : 0.25));
    s.energy = clamp(s.energy + (state.sleeping ? +1.2 : -0.3));
  }
  state.lastTick = now; refreshBars(); saveState();
}

function update(dt){
  // food physics
  for(let i=food.length-1;i>=0;i--){
    const f=food[i]; if(f.eaten){ food.splice(i,1); continue; }
    f.vy += 0.006; f.vx *= 0.98; f.vy *= 0.99;
    f.x += f.vx * dt*60; f.y += f.vy * dt*60; f.rot += f.spin * dt;
    const bedY = canvas.clientHeight*0.82;
    if(f.y > bedY){ f.y = bedY; f.vy = 0; f.vx = 0; f.spin = 0; }
    f.x = Math.max(8, Math.min(canvas.clientWidth-8, f.x));
  }
  if(Math.random() < 0.1) spawnFilterBubble();
  for(let i=filterBubbles.length-1;i>=0;i--){
    const b=filterBubbles[i]; b.y -= 30*dt; b.x += Math.sin(b.y*0.05)*4*dt; b.a -= 0.3*dt;
    if(b.a<=0 || b.y < canvas.clientHeight*0.18) filterBubbles.splice(i,1);
  }

  // Play mode timer & ball
  if(play.active){
    play.timer -= dt;
    if(play.timer <= 0){ endPlay(); }
    else { updateBall(dt); }
  }
  // speech bubble timer
  if(play.bubble.t > 0){ play.bubble.t -= dt; if(play.bubble.t < 0) play.bubble.t = 0; }

  updateAxolotl(dt);
}

function render(dt){
  const w=canvas.clientWidth, h=canvas.clientHeight;
  ctx.drawImage(bg, 0, 0, w, h); // background
  drawCaustics(w, h, dt);

  // food flakes
  for(const f of food){
    ctx.save(); ctx.translate(f.x, f.y); ctx.rotate(f.rot);
    const grd = ctx.createLinearGradient(-f.size, -f.size, f.size, f.size);
    grd.addColorStop(0, '#fdd7a3'); grd.addColorStop(1, '#f8b88b');
    ctx.fillStyle = grd; roundRect(ctx, -f.size, -f.size*0.6, f.size*2, f.size*1.2, 2, true); ctx.restore();
  }

  // ball (if playing)
  drawBall();

  // axolotl
  drawAxolotlSmall();

  // bubbles (filter/clean)
  for(const b of filterBubbles){
    ctx.globalAlpha = Math.max(0, Math.min(1,b.a));
    ctx.fillStyle = '#ffffff'; ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fill();
  }
  ctx.globalAlpha = 1;

  // speech bubble (after play)
  if(play.bubble.t > 0 && play.bubble.text){
    drawSpeechBubble(axolotl.x, axolotl.y - 40, play.bubble.text);
  }
}

/* =========================
   Helpers
   ========================= */
function hexToRgb(hex){ const m=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return m ? {r:parseInt(m[1],16), g:parseInt(m[2],16), b:parseInt(m[3],16)} : null; }
function drawSpeechBubble(px, py, text){
  const padding=8, maxW=Math.min(240, canvas.clientWidth*0.8);
  ctx.font='600 13px system-ui, sans-serif';
  const lines = wrapText(text, maxW-2*padding);
  const lineH = 16, w = Math.max(60, Math.min(maxW, Math.max(...lines.map(l=>ctx.measureText(l).width)) + 2*padding));
  const h = lines.length*lineH + 2*padding;
  let x = px - w/2, y = py - h - 12;
  x = Math.max(8, Math.min(canvas.clientWidth - w - 8, x));
  y = Math.max(8, y);

  // bubble
  ctx.save();
  ctx.fillStyle='rgba(255,255,255,0.95)';
  ctx.strokeStyle='rgba(0,0,0,0.12)'; ctx.lineWidth=1;
  roundRect(ctx, x, y, w, h, 10, true); ctx.stroke();

  // tail
  const tailX = Math.max(x+10, Math.min(x+w-10, px));
  ctx.beginPath(); ctx.moveTo(tailX-8, y+h); ctx.lineTo(tailX+8, y+h); ctx.lineTo(px, py-6); ctx.closePath();
  ctx.fillStyle='rgba(255,255,255,0.95)'; ctx.fill(); ctx.strokeStyle='rgba(0,0,0,0.12)'; ctx.stroke();

  // text
  ctx.fillStyle='#1c1c1f';
  for(let i=0;i<lines.length;i++){ ctx.fillText(lines[i], x+padding, y+padding + (i+0.8)*lineH); }
  ctx.restore();
}
function wrapText(text, maxWidth){
  const words=text.split(' '), lines=[]; let line='';
  for(const w of words){
    const test=line? line+' '+w : w;
    if(ctx.measureText(test).width > maxWidth){ if(line) lines.push(line); line=w; }
    else line=test;
  }
  if(line) lines.push(line);
  return lines;
}

/* =========================
   Loop / lifecycle
   ========================= */
let last = 0, accum = 0;
function frame(ts){
  if(!last) last = ts;
  const dt = Math.min(0.1, (ts - last)/1000); last = ts;
  accum += dt; while(accum >= 1){ tickOneSecond(); accum -= 1; saveState(); }
  update(dt); render(dt); requestAnimationFrame(frame);
}

/* =========================
   Error overlay
   ========================= */
const debugEl = document.getElementById('debug');
function showError(e){ debugEl.style.display='block'; debugEl.textContent='Error: ' + (e?.message || e); }
window.addEventListener('error', ev => showError(ev.error || ev.message));
window.addEventListener('unhandledrejection', ev => showError(ev.reason));

/* =========================
   Start
   ========================= */
function start(){
  sizeCanvas(); drawTankBackground(canvas.clientWidth, canvas.clientHeight);
  offlineProgress(); refreshBars();
  axolotl.x = canvas.clientWidth*0.55; axolotl.y = canvas.clientHeight*0.55;
  requestAnimationFrame(frame);
}
if(document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', start, { once:true }); } else { start(); }
document.addEventListener('visibilitychange', ()=>{ if(document.hidden) saveState(); });
</script>
</body>
</html>
