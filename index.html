<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Charlie's Axolotl Pet</title>
<meta property="og:title" content="Charlie's Axolotl Pet" />
<meta name="twitter:title" content="Charlie's Axolotl Pet" />
<style>
  :root{
    --bg:#f7f5ff; --card:#fff; --text:#222; --muted:#6b6b6b; --accent:#7c5cff;
    --good:#4caf50; --warn:#ffb300; --bad:#ff5252;
  }
  html,body{height:100%;margin:0;background:
    radial-gradient(1000px 700px at 20% -10%, #ffe9f2, transparent 60%),
    radial-gradient(800px 500px at 120% 10%, #eaf4ff, transparent 50%),
    var(--bg);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
    color:var(--text);
  }
  .wrap{max-width:520px;margin:0 auto;padding:16px 12px calc(env(safe-area-inset-bottom, 0) + 24px);}
  .card{background:var(--card);border-radius:20px;box-shadow:0 10px 30px rgba(50,34,120,.1);padding:10px 10px 14px;}
  .topbar{display:flex;align-items:center;justify-content:space-between;gap:8px;margin-bottom:8px;}
  .title{font-weight:800;letter-spacing:.3px;font-size:16px;display:flex;align-items:center;gap:8px;}
  .title .dot{width:10px;height:10px;border-radius:50%;background:var(--accent);}
  .controls{display:flex;align-items:center;gap:8px;}
  .controls input[type="text"]{width:160px;border:1px solid #e5e5ee;border-radius:12px;padding:6px 10px;outline:none;background:#fbfbff;}
  .controls input[type="color"]{appearance:none;border:none;width:32px;height:32px;background:none;padding:0;}
  .controls input[type="color"]::-webkit-color-swatch-wrapper{padding:0;}
  .controls input[type="color"]::-webkit-color-swatch{border:2px solid #e5e5ee;border-radius:8px;}
  .canvas-holder{position:relative;border-radius:16px;overflow:hidden;outline:1px solid rgba(124,92,255,.10);}
  #gameCanvas{display:block;width:100%;background:#0b0b10;}
  /* age badge overlay */
  .age-badge{
    position:absolute; left:8px; top:8px;
    background:rgba(255,255,255,0.9); border:1px solid rgba(0,0,0,0.08);
    border-radius:10px; padding:4px 8px; font-size:12px; display:flex; align-items:center; gap:6px;
    backdrop-filter: blur(4px);
  }
  .age-badge .icon{width:14px;height:14px;border-radius:3px;background:linear-gradient(180deg,#ffb3d1,#ff87c5); position:relative;}
  .age-badge .icon::after{content:''; position:absolute; left:3px; top:-3px; width:8px; height:4px; border-radius:2px; background:#fff;}
  .bars{display:grid;grid-template-columns:1fr;gap:8px;margin:12px 4px 6px;}
  .bar{background:#f2f0ff;border-radius:999px;height:12px;position:relative;overflow:hidden;}
  .bar span{position:absolute;left:0;top:0;bottom:0;width:50%;background:linear-gradient(90deg,#9d82ff,#ff7ad9);border-radius:999px;transition:width .25s ease;}
  .barlabel{font-size:12px;color:var(--muted);margin:0 6px 2px;display:flex;justify-content:space-between;}
  .actions{display:grid;grid-template-columns:repeat(5,1fr);gap:8px;margin-top:10px;}
  .btn{border:none;padding:10px 8px;border-radius:14px;background:#f5f3ff;cursor:pointer;font-weight:700;font-size:12px;
       display:flex;flex-direction:column;align-items:center;gap:6px;box-shadow:inset 0 0 0 1px rgba(124,92,255,.15);}
  .btn:active{transform:translateY(1px) scale(.99);}
  .btn .emoji{font-size:20px;}
  .hint{text-align:center;font-size:12px;color:var(--muted);margin-top:10px;}
  /* Decor menu */
  #decorMenu{
    position:absolute; right:8px; top:8px; z-index:4;
    background:rgba(255,255,255,0.98); border:1px solid rgba(0,0,0,0.1); border-radius:12px; padding:8px;
    display:none; box-shadow:0 12px 30px rgba(0,0,0,.15);
  }
  #decorMenu button{
    display:flex; align-items:center; gap:8px;
    border:none; background:#f5f3ff; padding:8px 10px; border-radius:10px; font-weight:700; cursor:pointer; margin:4px 0;
    box-shadow:inset 0 0 0 1px rgba(124,92,255,.15);
  }
  #decorMenu .title{font-weight:800; margin-bottom:6px;}
  /* Debug overlay */
  #debug{position:fixed;left:8px;bottom:8px;max-width:90vw;background:#2b2b2b;color:#fff;font:12px/1.3 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
         padding:8px 10px;border-radius:8px;box-shadow:0 10px 30px rgba(0,0,0,.25);display:none;white-space:pre-wrap;z-index:9999;}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <div class="topbar">
      <div class="title"><span class="dot"></span> Charlie's Axolotl Pet</div>
      <div class="controls">
        <input id="nameInput" type="text" placeholder="Name me‚Ä¶" />
        <input id="colorInput" type="color" value="#f6b6d2" title="Axolotl color" />
      </div>
    </div>

    <div class="canvas-holder" id="canvasHolder">
      <canvas id="gameCanvas"></canvas>
      <div class="age-badge" id="ageBadge">
        <span class="icon"></span><span id="ageText">1 day old</span>
      </div>
      <div id="decorMenu">
        <div class="title">Add decor</div>
        <button id="addPlant">üåø Add plant</button>
        <button id="addRock">ü™® Add rock</button>
        <button id="addHouse">üè† Add little house</button>
        <button id="closeDecor">‚úñ Close</button>
      </div>
    </div>

    <div class="bars">
      <div class="barlabel"><span>Hunger</span><strong id="hungerVal">‚Äî</strong></div>
      <div class="bar"><span id="hungerBar"></span></div>
      <div class="barlabel"><span>Fun</span><strong id="funVal">‚Äî</strong></div>
      <div class="bar"><span id="funBar"></span></div>
      <div class="barlabel"><span>Energy</span><strong id="energyVal">‚Äî</strong></div>
      <div class="bar"><span id="energyBar"></span></div>
      <div class="barlabel"><span>Clean</span><strong id="cleanVal">‚Äî</strong></div>
      <div class="bar"><span id="cleanBar"></span></div>
    </div>

    <div class="actions">
      <button class="btn" id="feed"><span class="emoji">ü´ó</span>Feed</button>
      <button class="btn" id="play"><span class="emoji">üéæ</span>Play</button>
      <button class="btn" id="sleep"><span class="emoji">üåô</span>Sleep</button>
      <button class="btn" id="clean"><span class="emoji">ü´ß</span>Clean</button>
      <button class="btn" id="decor"><span class="emoji">üè°</span>Decor</button>
    </div>

    <div class="hint">Tip: tap the tank to drop a food flake. Everything autosaves.</div>
  </div>
</div>

<div id="debug"></div>

<script>
/* =========================
   Mobile-safe canvas setup
   ========================= */
const holder = document.getElementById('canvasHolder');
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
const ageBadge = document.getElementById('ageBadge');
const ageText  = document.getElementById('ageText');
const decorMenuEl = document.getElementById('decorMenu');

function sizeCanvas(){
  const cssW = Math.max(300, holder.clientWidth || 360);
  const cssH = Math.round(cssW * 16/9);
  canvas.style.width = cssW + 'px';
  canvas.style.height = cssH + 'px';
  ageBadge.style.transform = 'translateZ(0)';

  const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  const w = cssW * dpr, h = cssH * dpr;
  if (canvas.width !== w || canvas.height !== h) { canvas.width = w; canvas.height = h; }
  ctx.setTransform(1,0,0,1,0,0);
  ctx.scale(dpr, dpr);

  drawTankBackground(canvas.clientWidth, canvas.clientHeight);
}
window.addEventListener('resize', sizeCanvas, { passive: true });
window.addEventListener('orientationchange', () => setTimeout(sizeCanvas, 50), { passive: true });

/* =========================
   State, UI & persistence
   ========================= */
const STORAGE_KEY = 'axolotl_tank_decor_age_v1';
const defaultState = () => ({
  name: 'Axie',
  color: '#f6b6d2',
  stats: { hunger: 70, fun: 70, energy: 70, clean: 70 },
  lastTick: Date.now(),
  birthAt: Date.now(),
  sleeping: false,
  decor: [] // {type:'plant'|'rock'|'house', x, y}
});
function loadState(){ try{ const raw = localStorage.getItem(STORAGE_KEY); if(!raw) return defaultState();
  const data = JSON.parse(raw); return {...defaultState(), ...data, stats:{...defaultState().stats, ...(data.stats||{})}};
} catch{ return defaultState(); } }
function saveState(){ try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }catch{} }
function clamp(v){ return Math.max(0, Math.min(100, v)); }
let state = loadState();

const nameInput = document.getElementById('nameInput');
const colorInput = document.getElementById('colorInput');
const hungerBar = document.getElementById('hungerBar');
const funBar    = document.getElementById('funBar');
const energyBar = document.getElementById('energyBar');
const cleanBar  = document.getElementById('cleanBar');
const hungerVal = document.getElementById('hungerVal');
const funVal    = document.getElementById('funVal');
const energyVal = document.getElementById('energyVal');
const cleanVal  = document.getElementById('cleanVal');

nameInput.value = state.name;
colorInput.value = state.color;

nameInput.addEventListener('input', ()=>{ state.name = nameInput.value || 'Axie'; saveState(); });
colorInput.addEventListener('input', ()=>{ state.color = colorInput.value; saveState(); });

function moodScore(){ const s = state.stats;
  return Math.max(0, Math.min(1, (s.hunger + s.fun + s.energy + s.clean)/400)); }
function setBar(el, val, labelEl){
  const pct = clamp(val); el.style.width = pct + '%'; labelEl.textContent = Math.round(pct);
  let bg = 'linear-gradient(90deg, #9d82ff, #ff7ad9)';
  if(pct < 30) bg = 'linear-gradient(90deg, var(--bad), #ff9aa6)';
  else if(pct < 60) bg = 'linear-gradient(90deg, var(--warn), #ffd16b)'; else bg = 'linear-gradient(90deg, var(--good), #7dffa6)';
  el.style.background = bg;
}
function refreshBars(){ const s = state.stats;
  setBar(hungerBar, s.hunger, hungerVal); setBar(funBar, s.fun, funVal);
  setBar(energyBar, s.energy, energyVal); setBar(cleanBar, s.clean, cleanVal); }

/* =========================
   Environment & visuals
   ========================= */
const bg = document.createElement('canvas');
const bgCtx = bg.getContext('2d');

// Sleep & bed state
let bed = { x: 0, y: 0, w: 0, h: 0 };
const sleep = { mode: 'awake', dark: 0, zzz: [] }; // mode: 'awake' | 'going' | 'asleep'

// Decor runtime caches (for house overlay framing)
let decorBack = [];  // items to draw before axolotl
let decorFront = []; // items to draw after axolotl (house frame)

function drawTankBackground(w, h){
  if (w <= 0 || h <= 0) return;
  bg.width = w; bg.height = h;
  const g = bgCtx;
  g.setTransform(1,0,0,1,0,0);
  const grad = g.createLinearGradient(0,0,0,h);
  grad.addColorStop(0, '#cfefff'); grad.addColorStop(0.5, '#d9f4ff'); grad.addColorStop(1, '#eafaff');
  g.fillStyle = grad; g.fillRect(0,0,w,h);
  const rad = g.createRadialGradient(w*0.5, h*0.2, w*0.1, w*0.5, h*0.2, w*0.8);
  rad.addColorStop(0,'rgba(255,255,255,0)'); rad.addColorStop(1,'rgba(0,30,60,0.12)');
  g.fillStyle = rad; g.fillRect(0,0,w,h);

  // substrate
  const bedH = h*0.18, bedY = h - bedH;
  g.fillStyle = '#d7c7a2'; roundRect(g, 0, bedY, w, bedH, 18, true);
  for(let i=0;i<160;i++){
    const px = Math.random()*w, py = bedY + Math.random()*bedH*0.9, r = 1.5 + Math.random()*3.5;
    g.fillStyle = pebbleColor();
    g.beginPath(); g.ellipse(px, py, r*1.2, r, Math.random()*Math.PI, 0, Math.PI*2); g.fill();
  }
  drawRock(g, w*0.18, bedY-6, 48, 28); drawRock(g, w*0.30, bedY-2, 32, 18);
  drawCave(g, w*0.72, bedY-4, 110, 60);
  drawPlantCluster(g, w*0.1,  bedY, 6,  bedH*0.9);
  drawPlantCluster(g, w*0.42, bedY, 7,  bedH*1.0);
  drawPlantCluster(g, w*0.86, bedY, 5,  bedH*0.85);

  // --- Cozy bed (right side) ---
  const bx = w * 0.70, by = bedY - 4;
  const bw = 70, bh = 22;
  g.fillStyle = '#8b6f47'; roundRect(g, bx - bw/2, by + 8, bw, 6, 3, true);          // base
  g.fillStyle = '#9c805a'; roundRect(g, bx - (bw-12)/2, by - bh + 8, bw - 12, bh, 6, true); // cushion
  bed = { x: bx, y: by + 8, w: bw - 12, h: bh };

  // rebuild decor caches for current size
  rebuildDecorLayers();
}
function pebbleColor(){ const p=['#cdbb96','#b8a57e','#e3d5b0','#a18f72','#d1c09d','#b59f7a']; return p[(Math.random()*p.length)|0]; }
function drawRock(g, x, y, w, h){ g.save(); g.translate(x,y);
  const grd = g.createLinearGradient(0,-h,0,h); grd.addColorStop(0,'#8f978f'); grd.addColorStop(1,'#6c746c');
  g.fillStyle = grd; g.beginPath(); g.moveTo(-w*0.5,0); g.quadraticCurveTo(0,-h, w*0.5,0); g.closePath(); g.fill(); g.restore(); }
function drawCave(g, x, y, w, h){
  g.save(); g.translate(x,y); g.fillStyle = '#6b6e6f';
  g.beginPath(); g.moveTo(-w/2,0); g.quadraticCurveTo(0,-h, w/2,0); g.quadraticCurveTo(0,-h*0.6, -w/2,0); g.fill();
  g.fillStyle = '#1c2426'; g.beginPath(); g.ellipse(0, h*0.12, w*0.36, h*0.25, 0, 0, Math.PI*2); g.fill(); g.restore();
}
function drawPlantCluster(g, baseX, baseY, stems, height){ for(let i=0;i<stems;i++){ const sway=(Math.random()*0.6+0.6);
  drawPlant(g, baseX + (i - stems/2)*8, baseY, height*(0.7+Math.random()*0.5), sway); } }
function drawPlant(g, x, baseY, h, k){
  g.save(); g.strokeStyle='#2f8f6e'; g.lineWidth=3; g.beginPath(); g.moveTo(x, baseY);
  for(let t=0;t<=1;t+=0.1){ const y = baseY - h*t; const curv = Math.sin(t*Math.PI)*k*20; const cx = x + curv; if(t===0) g.lineTo(x,y); else g.lineTo(cx,y); }
  g.stroke();
  for(let i=0;i<5;i++){ const sy=baseY - h*(i/6 + 0.1); g.fillStyle='#39a57f';
    g.beginPath(); g.ellipse(x + (i%2? 10:-10), sy, 10, 4, (i%2?0.6:-0.6), 0, Math.PI*2); g.fill(); }
  g.restore();
}
function roundRect(g, x, y, w, h, r, fill){ const rr=Math.min(r,w/2,h/2);
  g.beginPath(); g.moveTo(x+rr,y); g.arcTo(x+w,y,x+w,y+h,rr); g.arcTo(x+w,y+h,x,y+h,rr); g.arcTo(x,y+h,x,y,rr); g.arcTo(x,y,x+w,y,rr); g.closePath(); if(fill) g.fill(); else g.stroke(); }

let causticT = 0;
function drawCaustics(w,h,dt){
  causticT += dt; ctx.globalAlpha=0.06;
  for(let i=0;i<3;i++){ const t=causticT*0.6 + i*0.8;
    ctx.beginPath();
    for(let x=0; x<=w; x+=6){ const y=Math.sin((x*0.015)+t)*6 + Math.cos((x*0.027)-t*1.3)*4 + h*0.35 + i*18;
      if(x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }
    ctx.strokeStyle='#ffffff'; ctx.lineWidth=2; ctx.stroke();
  } ctx.globalAlpha=1;
}

/* =========================
   Axolotl (small, swimming, growth by age)
   ========================= */
const axolotl = { x:120, y:260, vx:15, vy:0, dir:1, target:null, blinkT:0, eyeOpen:true, nibbleT:0, scale:1 };
function setRandomTarget(){ const margin=60;
  axolotl.target = { x: margin + Math.random()*(canvas.clientWidth - margin*2),
                     y: canvas.clientHeight*0.35 + Math.random()*canvas.clientHeight*0.35 }; }

function daysOld(){
  const ms = Date.now() - (state.birthAt || Date.now());
  return Math.max(1, Math.floor(ms / 86400000) + 1);
}
function updateAgeBadge(){
  const d = daysOld();
  ageText.textContent = d + (d===1 ? ' day old' : ' days old');
  // growth curve: 0‚Äì30 days ‚Üí 0.85 .. 1.25
  const t = Math.min(30, d) / 30;
  axolotl.scale = 0.85 + 0.40 * t;
}

function updateAxolotl(dt){
  // If sleeping or going to sleep: target the bed
  if (sleep.mode === 'going' || sleep.mode === 'asleep') {
    const targetX = bed.x;
    const targetY = bed.y - 10;
    axolotl.target = { x: targetX, y: targetY };

    const dx = targetX - axolotl.x, dy = targetY - axolotl.y, d = Math.hypot(dx,dy) || 1;
    const maxSpeed = 45, steer = 100;
    const desiredVx = (dx/d)*maxSpeed, desiredVy = (dy/d)*maxSpeed;
    axolotl.vx += (desiredVx - axolotl.vx)*Math.min(1, steer*dt/60);
    axolotl.vy += (desiredVy - axolotl.vy)*Math.min(1, steer*dt/60);

    if (d < 12) { sleep.mode = 'asleep'; axolotl.vx = 0; axolotl.vy = 0; }
  } else {
    // Awake: choose target (ball > food > house opening > wander)
    let target = null; let minD = 1e9;
    if (play.active && play.ball) { target = { x: play.ball.x, y: play.ball.y }; }
    if (!target) {
      for (const f of food) { if (!f.eaten) {
        const d = Math.hypot(f.x - axolotl.x, f.y - axolotl.y);
        if (d < minD) { minD = d; target = f; }
      } }
    }
    // Occasionally inspect house interior if present
    if (!target && Math.random() < 0.003) {
      const house = state.decor.find(d => d.type === 'house');
      if (house) {
        target = { x: house.x, y: house.y - 10 };
      }
    }

    if (target) axolotl.target = { x: target.x, y: target.y };
    else if (!axolotl.target || Math.random() < 0.006) setRandomTarget();

    if (axolotl.target) {
      const dx = axolotl.target.x - axolotl.x;
      const dy = axolotl.target.y - axolotl.y;
      const d = Math.hypot(dx,dy) || 1;
      const maxSpeed = play.active ? 75 : 55, steer = 100;
      const desiredVx = (dx/d)*maxSpeed, desiredVy = (dy/d)*maxSpeed;
      axolotl.vx += (desiredVx - axolotl.vx)*Math.min(1, steer*dt/60);
      axolotl.vy += (desiredVy - axolotl.vy)*Math.min(1, steer*dt/60);
    }
  }

  // Integration & walls
  axolotl.vx *= (1 - 0.05*dt); axolotl.vy *= (1 - 0.05*dt);
  axolotl.x += axolotl.vx * dt; axolotl.y += axolotl.vy * dt;
  const m=24; axolotl.x = Math.max(m, Math.min(canvas.clientWidth-m, axolotl.x));
  axolotl.y = Math.max(canvas.clientHeight*0.28, Math.min(canvas.clientHeight*0.82, axolotl.y));
  if (Math.abs(axolotl.vx)>1) axolotl.dir = axolotl.vx>0 ? 1 : -1;

  // Blink
  axolotl.blinkT += dt;
  if (axolotl.eyeOpen && axolotl.blinkT > 2.6 + Math.random()*0.6){ axolotl.eyeOpen=false; axolotl.blinkT=0; }
  else if (!axolotl.eyeOpen && axolotl.blinkT > 0.14){ axolotl.eyeOpen=true; axolotl.blinkT=0; }

  // Eat nearby food (only when awake)
  if (sleep.mode === 'awake') {
    for (const f of food) { if (!f.eaten) {
      const d = Math.hypot(f.x-axolotl.x, f.y-axolotl.y);
      if (d < 18){ f.eaten=true; axolotl.nibbleT=0.35; state.stats.hunger = clamp(state.stats.hunger + 8); state.stats.fun = clamp(state.stats.fun + 3); refreshBars(); }
    } }
  }

  // Bop the ball (only when awake)
  if (sleep.mode === 'awake' && play.active && play.ball) {
    const b = play.ball; const dx=b.x-axolotl.x, dy=b.y-axolotl.y, d=Math.hypot(dx,dy);
    if (d < b.r + 16) {
      const nx = (dx/d)||1, ny = (dy/d)||0;
      const impulse = 140;
      b.vx += nx * impulse; b.vy += ny * impulse;
      axolotl.nibbleT = 0.2;
      state.stats.fun = clamp(state.stats.fun + 0.8);
    }
  }
}

function drawAxolotlSmall(){
  const scale = axolotl.scale;
  const x=axolotl.x, y=axolotl.y, dir=axolotl.dir;
  const bodyColor = hexToRgb(state.color) || {r:246,g:182,b:210};
  ctx.save(); ctx.translate(x,y); ctx.scale(dir*scale,1*scale);
  const t = performance.now()/1000; const wag = Math.sin(t*8 + x*0.02)*6;

  ctx.fillStyle = `rgba(${bodyColor.r},${bodyColor.g},${bodyColor.b},0.9)`;
  ctx.beginPath(); ctx.ellipse(32, 8, 34, 12, 0.3, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(0, 0, 32, 18, 0, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(-24, -6, 22, 18, 0, 0, Math.PI*2); ctx.fill();

  ctx.fillStyle = 'rgba(255,135,197,0.9)';
  for(let i=0;i<3;i++){ ctx.beginPath(); ctx.ellipse(-36, -12+i*8, 10+i*2, 4, -0.2, 0, Math.PI*2); ctx.fill();
                        ctx.beginPath(); ctx.ellipse(-10, -10+i*8, 10+i*2, 4, 0.2, 0, Math.PI*2); ctx.fill(); }

  ctx.fillStyle = `rgba(${bodyColor.r},${bodyColor.g},${bodyColor.b},0.35)`;
  ctx.beginPath(); ctx.moveTo(-6, -18);
  ctx.quadraticCurveTo(10, -18 - wag*0.08, 26, -10 - wag*0.12);
  ctx.quadraticCurveTo(10, -12, -6, -18); ctx.fill();

  ctx.fillStyle = '#1d1f22';
  if(axolotl.eyeOpen){ ctx.beginPath(); ctx.ellipse(-32, -10, 2.6, 3.4, 0, 0, Math.PI*2); ctx.fill();
                        ctx.beginPath(); ctx.ellipse(-16, -10, 2.6, 3.4, 0, 0, Math.PI*2); ctx.fill();
  } else { ctx.fillRect(-35, -10, 6, 2); ctx.fillRect(-19, -10, 6, 2); }

  ctx.strokeStyle = '#1d1f22'; ctx.lineWidth = 2; ctx.beginPath();
  const smile = axolotl.nibbleT>0 ? 0.0 : 0.6; ctx.moveTo(-30, -2);
  ctx.quadraticCurveTo(-24, -2 + 6*smile, -18, -2); ctx.stroke();
  ctx.restore();
}

/* =========================
   Food flakes & bubbles
   ========================= */
const food = []; // {x,y,vx,vy,rot,spin,size,eaten:false}
function spawnFood(cx, cy, count=10){
  for(let i=0;i<count;i++){
    food.push({ x: cx+(Math.random()*40-20), y: cy+(Math.random()*10-5), vx:(Math.random()*20-10)/60,
      vy:(5+Math.random()*15)/60, rot:Math.random()*Math.PI*2, spin:(Math.random()<0.5?-1:1)*(0.5+Math.random())*0.8,
      size: 4+Math.random()*5, eaten:false });
  }
}
const filterBubbles = [];
function spawnFilterBubble(){ const x=24+Math.random()*10, y=canvas.clientHeight*0.25+Math.random()*30;
  filterBubbles.push({x,y,r:2+Math.random()*2,a:0.8}); }

/* =========================
   PLAY MODE: ball chase
   ========================= */
const play = {
  active: false,
  timer: 0,
  ball: null,      // {x,y,vx,vy,r}
  bubble: { text: "", t: 0 } // speech bubble timer
};
function startPlay(){
  play.active = true;
  play.timer = 20; // seconds
  play.ball = {
    x: canvas.clientWidth*0.55,
    y: canvas.clientHeight*0.35,
    vx: (Math.random()*120-60),
    vy: (Math.random()*60),
    r: 10
  };
}
function endPlay(){
  play.active = false;
  play.ball = null;
  play.bubble.text = "Thank you for playing with me, Charlie";
  play.bubble.t = 3.5; // show for 3.5s
}
function updateBall(dt){
  if(!play.ball) return;
  const b = play.ball;
  b.vx *= 0.995; b.vy *= 0.995; // mild drag
  b.y += b.vy * dt; b.x += b.vx * dt;
  const left=10, right=canvas.clientWidth-10, top=canvas.clientHeight*0.22, bottom=canvas.clientHeight*0.82;
  if(b.x-b.r < left){ b.x = left + b.r; b.vx = Math.abs(b.vx); }
  if(b.x+b.r > right){ b.x = right - b.r; b.vx = -Math.abs(b.vx); }
  if(b.y-b.r < top){ b.y = top + b.r; b.vy = Math.abs(b.vy); }
  if(b.y+b.r > bottom){ b.y = bottom - b.r; b.vy = -Math.abs(b.vy); }
}
function drawBall(){
  if(!play.ball) return;
  const b = play.ball;
  const grad = ctx.createRadialGradient(b.x-3, b.y-3, 2, b.x, b.y, b.r);
  grad.addColorStop(0, '#ffe9a9'); grad.addColorStop(1, '#ffb36f');
  ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fill();
  ctx.strokeStyle = 'rgba(0,0,0,0.15)'; ctx.lineWidth = 1; ctx.stroke();
  ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.beginPath(); ctx.arc(b.x-4, b.y-5, 2.5, 0, Math.PI*2); ctx.fill();
}

/* =========================
   Simple interactions
   ========================= */
document.getElementById('feed').onclick = ()=>{
  spawnFood(canvas.clientWidth*0.5, canvas.clientHeight*0.18, 18);
  state.stats.hunger = clamp(state.stats.hunger + 10);
  refreshBars(); saveState();
};
document.getElementById('play').onclick = ()=>{
  startPlay();
  state.stats.fun = clamp(state.stats.fun + 5);
  refreshBars(); saveState();
};
// Sleep button: start/stop bedtime sequence
document.getElementById('sleep').onclick = ()=>{
  if (sleep.mode === 'awake') {
    sleep.mode = 'going';      // start bedtime
    state.sleeping = true;
    state.stats.energy = clamp(state.stats.energy + 8);
  } else {
    sleep.mode = 'awake';      // wake up
    state.sleeping = false;
  }
  refreshBars(); saveState();
};
document.getElementById('clean').onclick = ()=>{
  state.stats.clean = clamp(state.stats.clean + 16);
  for(let i=0;i<14;i++){
    filterBubbles.push({ x: canvas.clientWidth*0.5 + (Math.random()*80-40),
      y: canvas.clientHeight*0.78 + Math.random()*6, r: 2+Math.random()*3, a: 0.9 });
  }
  refreshBars(); saveState();
};
document.getElementById('decor').onclick = ()=>{
  decorMenuEl.style.display = decorMenuEl.style.display === 'none' || decorMenuEl.style.display==='' ? 'block' : 'none';
};
document.getElementById('closeDecor').onclick = ()=>{ decorMenuEl.style.display = 'none'; };
document.getElementById('addPlant').onclick = ()=>{ addDecor('plant'); };
document.getElementById('addRock').onclick  = ()=>{ addDecor('rock');  };
document.getElementById('addHouse').onclick = ()=>{ addDecor('house'); };
// Tap tank = drop flakes at tap
canvas.addEventListener('pointerdown', (e)=>{
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left); const y = (e.clientY - rect.top);
  spawnFood(x, Math.max(20,y), 8);
});

/* =========================
   Decor system
   ========================= */
function addDecor(type){
  const floorY = canvas.clientHeight*0.82;
  const x = 40 + Math.random()*(canvas.clientWidth-80);
  const y = floorY;
  state.decor.push({ type, x, y });
  saveState();
  rebuildDecorLayers();
  decorMenuEl.style.display = 'none';
}

function rebuildDecorLayers(){
  decorBack = [];
  decorFront = [];
  const floorY = canvas.clientHeight*0.82;

  for(const d of state.decor){
    if(d.type === 'plant'){
      // vary height
      const h = (canvas.clientHeight*0.18) * (0.6 + Math.random()*0.6);
      decorBack.push(ctx2 => {
        drawPlantCluster(ctx2, d.x, floorY, 4 + ((Math.random()*2)|0), h);
      });
    } else if(d.type === 'rock'){
      const w= 28 + Math.random()*30, h= 16 + Math.random()*16;
      decorBack.push(ctx2 => { drawRock(ctx2, d.x, floorY-2, w, h); });
    } else if(d.type === 'house'){
      // house has back body and front frame (overlay) with doorway opening
      const size = 82;
      const doorwayR = 16;
      decorBack.push(ctx2 => { drawHouseBack(ctx2, d.x, floorY-4, size, doorwayR); });
      decorFront.push(ctx2 => { drawHouseFront(ctx2, d.x, floorY-4, size, doorwayR); });
      // mark a ‚Äúdoor center‚Äù for wandering interest
      d.door = { x: d.x, y: floorY - 10 };
    }
  }
}

function drawHouseBack(g, x, y, size, rDoor){
  g.save(); g.translate(x,y);
  // base body
  g.fillStyle = '#9aa7c6';
  roundRect(g, -size/2, -size*0.6, size, size*0.6, 10, true);
  // roof (back)
  g.fillStyle = '#7e86a1';
  g.beginPath(); g.moveTo(-size/2, -size*0.6); g.lineTo(0, -size); g.lineTo(size/2, -size*0.6); g.closePath(); g.fill();
  // doorway opening (clear with dark)
  g.fillStyle = '#111b24';
  g.beginPath(); g.ellipse(0, -size*0.25, rDoor*1.1, rDoor*1.5, 0, 0, Math.PI*2); g.fill();
  g.restore();
}
function drawHouseFront(g, x, y, size, rDoor){
  g.save(); g.translate(x,y);
  g.strokeStyle = 'rgba(0,0,0,0.18)'; g.lineWidth = 2;
  g.fillStyle = 'rgba(255,255,255,0.08)';
  // front frame around doorway
  g.beginPath(); g.ellipse(0, -size*0.25, rDoor*1.2, rDoor*1.6, 0, 0, Math.PI*2); g.stroke();
  g.restore();
}

/* =========================
   Ambient life: snails
   ========================= */
const snails = []; // {x,y,mode:'floor'|'up'|'down', dir:1|-1, speed}
function spawnSnails(n=2){
  const floorY = canvas.clientHeight*0.82;
  for(let i=0;i<n;i++){
    snails.push({
      x: 30 + Math.random()*(canvas.clientWidth-60),
      y: floorY,
      mode: 'floor',
      dir: Math.random()<0.5 ? -1 : 1,
      speed: 8 + Math.random()*6
    });
  }
}
function updateSnails(dt){
  const left=10, right=canvas.clientWidth-10, top=canvas.clientHeight*0.18, floorY=canvas.clientHeight*0.82;
  for(const s of snails){
    if(s.mode==='floor'){
      s.x += s.dir * s.speed * dt;
      if(s.x < left+6){ s.x = left+6; s.mode='up'; }
      if(s.x > right-6){ s.x = right-6; s.mode='up'; }
      s.y = floorY;
      if(Math.random()<0.001){ s.mode='up'; } // sometimes climb
    } else if(s.mode==='up'){
      s.y -= s.speed * 0.6 * dt;
      if(s.y < top+10){ s.mode='down'; }
    } else if(s.mode==='down'){
      s.y += s.speed * 0.5 * dt;
      if(s.y >= floorY){ s.y=floorY; s.mode='floor'; s.dir = Math.random()<0.5?-1:1; }
    }
  }
}
function drawSnail(x,y){
  ctx.save(); ctx.translate(x,y);
  // shell
  ctx.fillStyle = '#b58b64'; ctx.beginPath(); ctx.ellipse(0,-4,6,5,0,0,Math.PI*2); ctx.fill();
  ctx.strokeStyle='rgba(0,0,0,0.2)'; ctx.lineWidth=1; ctx.beginPath(); ctx.arc(-1,-4,3,0,Math.PI*1.7); ctx.stroke();
  // body
  ctx.fillStyle = '#866f5a'; ctx.beginPath(); ctx.ellipse(-6,-2,5,2.5,0,0,Math.PI*2); ctx.fill();
  // tentacles
  ctx.strokeStyle='#866f5a'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(-9,-4); ctx.lineTo(-11,-7); ctx.moveTo(-7,-4); ctx.lineTo(-8,-7); ctx.stroke();
  ctx.restore();
}

/* =========================
   Game loop & physics
   ========================= */
function tickOneSecond(){
  const s = state.stats;
  const baseDecay = state.sleeping ? 0.6 : 1.0;
  s.hunger = clamp(s.hunger - baseDecay);
  s.fun    = clamp(s.fun - (state.sleeping ? 0.35 : 0.7));
  s.clean  = clamp(s.clean - (state.sleeping ? 0.25 : 0.5));
  s.energy = clamp(s.energy + (state.sleeping ? +2.2 : -0.6));
  if(play.active){ s.fun = clamp(s.fun + 1.0); } // boost fun while playing
  refreshBars();
  state.lastTick = Date.now();
  updateAgeBadge();
}
function offlineProgress(){
  const now = Date.now(); const dt = Math.max(0, now - (state.lastTick || now));
  const seconds = Math.min(8*3600, Math.floor(dt/1000));
  for(let i=0;i<seconds;i++){ const s=state.stats; const bd = state.sleeping ? 0.5 : 1.0;
    s.hunger = clamp(s.hunger - bd/2);
    s.fun    = clamp(s.fun - (state.sleeping ? 0.15 : 0.35));
    s.clean  = clamp(s.clean - (state.sleeping ? 0.1 : 0.25));
    s.energy = clamp(s.energy + (state.sleeping ? +1.2 : -0.3));
  }
  state.lastTick = now; refreshBars(); saveState(); updateAgeBadge();
}

function update(dt){
  // Darken overlay target based on sleep mode
  const targetDark = (sleep.mode === 'going' || sleep.mode === 'asleep') ? 0.65 : 0.0;
  sleep.dark += (targetDark - sleep.dark) * Math.min(1, dt * 3);

  // food physics
  for(let i=food.length-1;i>=0;i--){
    const f=food[i]; if(f.eaten){ food.splice(i,1); continue; }
    f.vy += 0.006; f.vx *= 0.98; f.vy *= 0.99;
    f.x += f.vx * dt*60; f.y += f.vy * dt*60; f.rot += f.spin * dt;
    const floorY = canvas.clientHeight*0.82;
    if(f.y > floorY){ f.y = floorY; f.vy = 0; f.vx = 0; f.spin = 0; }
    f.x = Math.max(8, Math.min(canvas.clientWidth-8, f.x));
  }
  // filter bubbles
  if(Math.random() < 0.1) spawnFilterBubble();
  for(let i=filterBubbles.length-1;i>=0;i--){
    const b=filterBubbles[i]; b.y -= 30*dt; b.x += Math.sin(b.y*0.05)*4*dt; b.a -= 0.3*dt;
    if(b.a<=0 || b.y < canvas.clientHeight*0.18) filterBubbles.splice(i,1);
  }

  // Play mode timer & ball
  if(play.active){
    play.timer -= dt;
    if(play.timer <= 0){ endPlay(); }
    else { updateBall(dt); }
  }
  // speech bubble timer
  if(play.bubble.t > 0){ play.bubble.t -= dt; if(play.bubble.t < 0) play.bubble.t = 0; }

  // Zzz particles when asleep
  if (sleep.mode === 'asleep' && Math.random() < 0.04) {
    sleep.zzz.push({
      x: axolotl.x + (Math.random()*12-6),
      y: axolotl.y - 22 + (Math.random()*4-2),
      vy: -12 - Math.random()*8,
      a: 1.0,
      t: 0
    });
  }
  for (let i = sleep.zzz.length - 1; i >= 0; i--) {
    const z = sleep.zzz[i];
    z.t += dt;
    z.y += z.vy * dt;
    z.a -= 0.35 * dt;
    if (z.a <= 0 || z.y < canvas.clientHeight * 0.18) sleep.zzz.splice(i, 1);
  }

  // snails
  updateSnails(dt);

  updateAxolotl(dt);
}

function render(dt){
  const w=canvas.clientWidth, h=canvas.clientHeight;
  ctx.drawImage(bg, 0, 0, w, h); // background
  drawCaustics(w, h, dt);

  // Draw decor (back layer)
  for(const draw of decorBack){ draw(ctx); }

  // food flakes
  for(const f of food){
    ctx.save(); ctx.translate(f.x, f.y); ctx.rotate(f.rot);
    const grd = ctx.createLinearGradient(-f.size, -f.size, f.size, f.size);
    grd.addColorStop(0, '#fdd7a3'); grd.addColorStop(1, '#f8b88b');
    ctx.fillStyle = grd; roundRect(ctx, -f.size, -f.size*0.6, f.size*2, f.size*1.2, 2, true); ctx.restore();
  }

  // ball (if playing)
  drawBall();

  // axolotl
  drawAxolotlSmall();

  // decor (front overlays like house frame)
  for(const draw of decorFront){ draw(ctx); }

  // snails
  for(const s of snails){ drawSnail(s.x, s.y); }

  // bubbles (filter/clean)
  for(const b of filterBubbles){
    ctx.globalAlpha = Math.max(0, Math.min(1,b.a));
    ctx.fillStyle = '#ffffff'; ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fill();
  }
  ctx.globalAlpha = 1;

  // speech bubble (after play)
  if(play.bubble.t > 0 && play.bubble.text){
    drawSpeechBubble(axolotl.x, axolotl.y - 40, play.bubble.text);
  }

  // zzz glyphs (when asleep)
  if (sleep.zzz.length) {
    ctx.save();
    ctx.font = '700 20px system-ui, sans-serif';
    ctx.fillStyle = '#6a6a88';
    for (const z of sleep.zzz) {
      ctx.globalAlpha = Math.max(0, Math.min(1, z.a));
      ctx.fillText('z', z.x, z.y);
    }
    ctx.restore();
    ctx.globalAlpha = 1;
  }

  // Night overlay (on top of everything)
  if (sleep.dark > 0.01) {
    ctx.fillStyle = `rgba(10,20,40,${sleep.dark})`;
    ctx.fillRect(0, 0, w, h);
  }
}

/* =========================
   Helpers
   ========================= */
function hexToRgb(hex){ const m=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return m ? {r:parseInt(m[1],16), g:parseInt(m[2],16), b:parseInt(m[3],16)} : null; }
function drawSpeechBubble(px, py, text){
  const padding=8, maxW=Math.min(240, canvas.clientWidth*0.8);
  ctx.font='600 13px system-ui, sans-serif';
  const lines = wrapText(text, maxW-2*padding);
  const lineH = 16, w = Math.max(60, Math.min(maxW, Math.max(...lines.map(l=>ctx.measureText(l).width)) + 2*padding));
  const h = lines.length*lineH + 2*padding;
  let x = px - w/2, y = py - h - 12;
  x = Math.max(8, Math.min(canvas.clientWidth - w - 8, x));
  y = Math.max(8, y);
  ctx.save();
  ctx.fillStyle='rgba(255,255,255,0.95)';
  ctx.strokeStyle='rgba(0,0,0,0.12)'; ctx.lineWidth=1;
  roundRect(ctx, x, y, w, h, 10, true); ctx.stroke();
  const tailX = Math.max(x+10, Math.min(x+w-10, px));
  ctx.beginPath(); ctx.moveTo(tailX-8, y+h); ctx.lineTo(tailX+8, y+h); ctx.lineTo(px, py-6); ctx.closePath();
  ctx.fillStyle='rgba(255,255,255,0.95)'; ctx.fill(); ctx.strokeStyle='rgba(0,0,0,0.12)'; ctx.stroke();
  ctx.fillStyle='#1c1c1f';
  for(let i=0;i<lines.length;i++){ ctx.fillText(lines[i], x+padding, y+padding + (i+0.8)*lineH); }
  ctx.restore();
}
function wrapText(text, maxWidth){
  const words=text.split(' '), lines=[]; let line='';
  for(const w of words){
    const test=line? line+' '+w : w;
    if(ctx.measureText(test).width > maxWidth){ if(line) lines.push(line); line=w; }
    else line=test;
  }
  if(line) lines.push(line);
  return lines;
}

/* =========================
   Loop / lifecycle
   ========================= */
let last = 0, accum = 0;
function frame(ts){
  if(!last) last = ts;
  const dt = Math.min(0.1, (ts - last)/1000); last = ts;
  accum += dt; while(accum >= 1){ tickOneSecond(); accum -= 1; saveState(); }
  update(dt); render(dt); requestAnimationFrame(frame);
}

/* =========================
   Error overlay
   ========================= */
const debugEl = document.getElementById('debug');
function showError(e){ debugEl.style.display='block'; debugEl.textContent='Error: ' + (e?.message || e); }
window.addEventListener('error', ev => showError(ev.error || ev.message));
window.addEventListener('unhandledrejection', ev => showError(ev.reason));

/* =========================
   Start
   ========================= */
function start(){
  sizeCanvas();
  offlineProgress(); refreshBars(); updateAgeBadge();
  axolotl.x = canvas.clientWidth*0.55; axolotl.y = canvas.clientHeight*0.55;
  spawnSnails(2);
  rebuildDecorLayers();
  requestAnimationFrame(frame);
}
if(document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', start, { once:true }); } else { start(); }
document.addEventListener('visibilitychange', ()=>{ if(document.hidden) saveState(); });
</script>
</body>
</html>
